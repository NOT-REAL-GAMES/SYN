"#include \"BasicStructures.fxh\"\n"
"#include \"FullScreenTriangleVSOutput.fxh\"\n"
"#include \"PostFX_Common.fxh\"\n"
"#include \"TemporalAntiAliasingStructures.fxh\"\n"
"\n"
"#define FLT_EPS   5.960464478e-8\n"
"#define FLT_MAX   3.402823466e+38\n"
"\n"
"#if TAA_OPTION_INVERTED_DEPTH\n"
"    #define DepthFarPlane 0.0\n"
"#else\n"
"    #define DepthFarPlane 1.0\n"
"#endif // TAA_OPTION_INVERTED_DEPTH\n"
"\n"
"cbuffer cbCameraAttribs\n"
"{\n"
"    CameraAttribs g_CurrCamera;\n"
"    CameraAttribs g_PrevCamera;\n"
"}\n"
"\n"
"cbuffer cbTemporalAntiAliasingAttribs\n"
"{\n"
"    TemporalAntiAliasingAttribs g_TAAAttribs;\n"
"}\n"
"\n"
"Texture2D<float3> g_TextureCurrColor;\n"
"Texture2D<float4> g_TexturePrevColor;\n"
"Texture2D<float2> g_TextureMotion;\n"
"Texture2D<float>  g_TextureCurrDepth;\n"
"Texture2D<float>  g_TexturePrevDepth;\n"
"\n"
"SamplerState g_TexturePrevColor_sampler;\n"
"\n"
"struct PixelStatistic\n"
"{\n"
"    float3 Mean;\n"
"    float3 Variance;\n"
"    float3 StdDev;\n"
"};\n"
"\n"
"float3 RGBToYCoCg(float3 RGB)\n"
"{\n"
"    // float Y  = dot(float3(+0.25, +0.50, +0.25), RGB);\n"
"    // float Co = dot(float3(+0.50, +0.00, -0.50), RGB);\n"
"    // float Cg = dot(float3(-0.25, +0.50, -0.25), RGB);\n"
"\n"
"#if TAA_OPTION_YCOCG_COLOR_SPACE\n"
"    float Co   = RGB.x - RGB.z;\n"
"    float Temp = RGB.z + 0.5 * Co;\n"
"    float Cg   = RGB.y - Temp;\n"
"    float Y    = Temp + 0.5 * Cg;\n"
"    return float3(Y, Co, Cg);\n"
"#else\n"
"    return RGB;\n"
"#endif\n"
"}\n"
"\n"
"float3 YCoCgToRGB(float3 YCoCg)\n"
"{\n"
"    // float R = dot(float3(+1.0, +1.0, -1.0), YCoCg);\n"
"    // float G = dot(float3(+1.0, +0.0, +1.0), YCoCg);\n"
"    // float B = dot(float3(+1.0, -1.0, -1.0), YCoCg);\n"
"\n"
"#if TAA_OPTION_YCOCG_COLOR_SPACE\n"
"    float Tmp = YCoCg.x - 0.5 * YCoCg.z;\n"
"    float G   = YCoCg.z + Tmp;\n"
"    float B   = Tmp - 0.5 * YCoCg.y;\n"
"    float R   = B + YCoCg.y;\n"
"    return float3(R, G, B);\n"
"#else\n"
"    return YCoCg;\n"
"#endif\n"
"}\n"
"\n"
"float3 HDRToSDR(float3 Color)\n"
"{\n"
"    return Color * rcp(1.0 + Color);\n"
"}\n"
"\n"
"float3 SDRToHDR(float3 Color)\n"
"{\n"
"    return Color * rcp(1.0 - Color + FLT_EPS);\n"
"}\n"
"\n"
"float3 SampleCurrColor(int2 PixelCoord)\n"
"{\n"
"    return g_TextureCurrColor.Load(int3(PixelCoord, 0));\n"
"}\n"
"\n"
"float4 SamplePrevColor(int2 PixelCoord)\n"
"{\n"
"    return g_TexturePrevColor.Load(int3(PixelCoord, 0));\n"
"}\n"
"\n"
"float SampleCurrDepth(int2 PixelCoord)\n"
"{\n"
"    return g_TextureCurrDepth.Load(int3(PixelCoord, 0));\n"
"}\n"
"\n"
"float SamplePrevDepth(int2 PixelCoord)\n"
"{\n"
"    return g_TexturePrevDepth.Load(int3(PixelCoord, 0));\n"
"}\n"
"\n"
"float2 SampleMotion(int2 PixelCoord)\n"
"{\n"
"    return g_TextureMotion.Load(int3(PixelCoord, 0)) * F3NDC_XYZ_TO_UVD_SCALE.xy;\n"
"}\n"
"\n"
"float3 ClipToAABB(float3 ColorPrev, float3 ColorCurr, float3 AABBCentre, float3 AABBExtents)\n"
"{\n"
"    float MaxT = TAA_VARIANCE_INTERSECTION_MAX_T;\n"
"    float3 Direction = ColorCurr - ColorPrev;\n"
"    float3 Intersection = ((AABBCentre - sign(Direction) * AABBExtents) - ColorPrev) / Direction;\n"
"    float3 PossibleT = lerp(float3(MaxT + 1.0, MaxT + 1.0, MaxT + 1.0), Intersection, GreaterEqual(Intersection, float3(0.0, 0.0, 0.0)));\n"
"    float T = min(MaxT, min(PossibleT.x, min(PossibleT.y, PossibleT.z)));\n"
"    return lerp(ColorPrev, ColorPrev + Direction * T, Less(float3(T, T, T), float3(MaxT, MaxT, MaxT)));\n"
"}\n"
"\n"
"float ComputeDepthDisocclusionWeight(float CurrDepth, float PrevDepth)\n"
"{\n"
"    float LinearDepthCurr = DepthToCameraZ(CurrDepth, g_PrevCamera.mProj);\n"
"    float LinearDepthPrev = DepthToCameraZ(PrevDepth, g_PrevCamera.mProj);\n"
"    return exp(-abs(LinearDepthPrev - LinearDepthCurr) / LinearDepthCurr);\n"
"}\n"
"\n"
"float ComputeDepthDisocclusion(float2 Position, float2 PrevPosition)\n"
"{\n"
"    int2 PrevPositioni = int2(PrevPosition);\n"
"    float CurrDepth = SampleCurrDepth(int2(Position));\n"
"    float Disocclusion = 0.0;\n"
"\n"
"    const int SearchRadius = 1;\n"
"    for (int y = -SearchRadius; y <= SearchRadius; y++)\n"
"    {\n"
"        for (int x = -SearchRadius; x <= SearchRadius; x++)\n"
"        {\n"
"            int2 Location = PrevPositioni + int2(x, y);\n"
"            float PrevDepth = SamplePrevDepth(Location);\n"
"            float Weight = ComputeDepthDisocclusionWeight(CurrDepth, PrevDepth);\n"
"            Disocclusion = max(Disocclusion, Weight);\n"
"        }\n"
"    }\n"
"\n"
"    return Disocclusion > TAA_DEPTH_DISOCCLUSION_THRESHOLD ? 1.0 : 0.0;\n"
"}\n"
"\n"
"float4 SamplePrevColorCatmullRom(float2 Position)\n"
"{\n"
"    // Source: https://advances.realtimerendering.com/s2016/Filmic%20SMAA%20v7.pptx Slide 77\n"
"\n"
"    float2 TexelSize = g_CurrCamera.f4ViewportSize.zw;\n"
"    float2 CenterPosition = floor(Position - 0.5) + 0.5;\n"
"\n"
"    float2 F = Position - CenterPosition;\n"
"    float2 F2 = F * F;\n"
"    float2 F3 = F2 * F;\n"
"\n"
"    float2 W0 = -0.5 * F3 + F2 - 0.5 * F;\n"
"    float2 W1 = 1.5 * F3 - 2.5 * F2 + 1.0;\n"
"    float2 W2 = -1.5 * F3 + 2.0 * F2 + 0.5 * F;\n"
"    float2 W3 = 0.5 * F3 - 0.5 * F2;\n"
"    float2 W12 = W1 + W2;\n"
"\n"
"    float2 TexPos0  = (CenterPosition - 1.0) * TexelSize;\n"
"    float2 TexPos3  = (CenterPosition + 2.0) * TexelSize;\n"
"    float2 TexPos12 = (CenterPosition + W2 / W12) * TexelSize;\n"
"\n"
"    float P0 = W12.x * W0.y;\n"
"    float P1 = W0.x * W12.x;\n"
"    float P2 = W12.x * W12.y;\n"
"    float P3 = W3.x * W12.y;\n"
"    float P4 = W12.x * W3.y;\n"
"\n"
"    float4 Result = float4(0.0, 0.0, 0.0, 0.0);\n"
"    Result += g_TexturePrevColor.SampleLevel(g_TexturePrevColor_sampler, float2(TexPos12.x, TexPos0.y),  0.0) * P0;\n"
"    Result += g_TexturePrevColor.SampleLevel(g_TexturePrevColor_sampler, float2(TexPos0.x,  TexPos12.y), 0.0) * P1;\n"
"    Result += g_TexturePrevColor.SampleLevel(g_TexturePrevColor_sampler, float2(TexPos12.x, TexPos12.y), 0.0) * P2;\n"
"    Result += g_TexturePrevColor.SampleLevel(g_TexturePrevColor_sampler, float2(TexPos3.x,  TexPos12.y), 0.0) * P3;\n"
"    Result += g_TexturePrevColor.SampleLevel(g_TexturePrevColor_sampler, float2(TexPos12.x, TexPos3.y),  0.0) * P4;\n"
"\n"
"    return max(Result * rcp(P0 + P1 + P2 + P3 + P4), 0.0);\n"
"}\n"
"\n"
"float4 SamplePrevColorBilinear(float2 Position)\n"
"{\n"
"    return max(g_TexturePrevColor.SampleLevel(g_TexturePrevColor_sampler, Position * g_CurrCamera.f4ViewportSize.zw, 0.0), 0.0);\n"
"}\n"
"\n"
"float4 SamplePrevColor(float2 Position)\n"
"{\n"
"#if TAA_OPTION_BICUBIC_FILTER\n"
"    return SamplePrevColorCatmullRom(Position);\n"
"#else\n"
"    return SamplePrevColorBilinear(Position);\n"
"#endif\n"
"}\n"
"\n"
"// Welford\'s online algorithm:\n"
"//  https://en.wikipedia.org/wiki/Algorithms_for_calculating_variance\n"
"PixelStatistic ComputePixelStatisticYCoCgSDR(int2 PixelCoord)\n"
"{\n"
"    PixelStatistic Desc;\n"
"    float WeightSum = 0.0;\n"
"    float3 M1 = float3(0.0, 0.0, 0.0);\n"
"    float3 M2 = float3(0.0, 0.0, 0.0);\n"
"\n"
"    const int StatisticRadius = 1;\n"
"    for (int x = -StatisticRadius; x <= StatisticRadius; x++)\n"
"    {\n"
"        for (int y = -StatisticRadius; y <= StatisticRadius; y++)\n"
"        {\n"
"            int2 Location = ClampScreenCoord(PixelCoord + int2(x, y), int2(g_CurrCamera.f4ViewportSize.xy));\n"
"            float3 HDRColor = SampleCurrColor(Location);\n"
"            float3 SDRColor = RGBToYCoCg(HDRColor * rcp(1.0 + HDRColor));\n"
"#if TAA_OPTION_GAUSSIAN_WEIGHTING\n"
"            float Weight = exp(-3.0 * float(x * x + y * y) / ((float(StatisticRadius) + 1.0) * (float(StatisticRadius) + 1.0)));\n"
"#else\n"
"            float Weight = 1.0;\n"
"#endif\n"
"\n"
"            M1 += SDRColor * Weight;\n"
"            M2 += SDRColor * SDRColor * Weight;\n"
"            WeightSum += Weight;\n"
"\n"
"        }\n"
"    }\n"
"\n"
"    Desc.Mean = M1 / WeightSum;\n"
"    Desc.Variance = M2 / WeightSum - (Desc.Mean * Desc.Mean);\n"
"    Desc.StdDev = sqrt(max(Desc.Variance, 0.0));\n"
"    return Desc;\n"
"}\n"
"\n"
"float ComputeCorrectedAlpha(float Alpha)\n"
"{\n"
"    return min(g_TAAAttribs.TemporalStabilityFactor, saturate(1.0 / (2.0 - Alpha)));\n"
"}\n"
"\n"
"float4 ComputeTemporalAccumulationPS(in FullScreenTriangleVSOutput VSOut) : SV_Target0\n"
"{\n"
"    float2 Position = VSOut.f4PixelPos.xy;\n"
"    float2 Motion = SampleMotion(int2(Position.xy));\n"
"    float2 PrevPosition = Position.xy - Motion * g_CurrCamera.f4ViewportSize.xy;\n"
"\n"
"    if (!IsInsideScreen(PrevPosition, g_CurrCamera.f4ViewportSize.xy) || g_TAAAttribs.ResetAccumulation)\n"
"        return float4(SampleCurrColor(int2(Position)), 0.5);\n"
"\n"
"    float AspectRatio = g_CurrCamera.f4ViewportSize.x * g_CurrCamera.f4ViewportSize.w;\n"
"    float MotionFactor = saturate(1.0 - length(float2(Motion.x * AspectRatio, Motion.y)) * TAA_MOTION_VECTOR_DIFF_FACTOR);\n"
"    float DepthFactor = ComputeDepthDisocclusion(Position, PrevPosition);\n"
"\n"
"    float3 RGBHDRCurrColor = SampleCurrColor(int2(Position));\n"
"    float4 RGBHDRPrevColor = SamplePrevColor(PrevPosition);\n"
"\n"
"    float3 YCoCgSDRCurrColor = RGBToYCoCg(HDRToSDR(RGBHDRCurrColor.xyz));\n"
"    float3 YCoCgSDRPrevColor = RGBToYCoCg(HDRToSDR(RGBHDRPrevColor.xyz));\n"
"\n"
"    if (g_TAAAttribs.SkipRejection)\n"
"    {\n"
"        float3 RGBHDROutput = SDRToHDR(YCoCgToRGB(lerp(YCoCgSDRCurrColor, YCoCgSDRPrevColor, RGBHDRPrevColor.a)));\n"
"        return float4(RGBHDROutput, ComputeCorrectedAlpha(RGBHDRPrevColor.a));\n"
"    }\n"
"\n"
"    float VarianceGamma = lerp(TAA_MIN_VARIANCE_GAMMA, TAA_MAX_VARIANCE_GAMMA, MotionFactor * MotionFactor);\n"
"    PixelStatistic PixelStat = ComputePixelStatisticYCoCgSDR(int2(Position.xy));\n"
"    float3 YCoCgSDRClampedColor = ClipToAABB(YCoCgSDRPrevColor, YCoCgSDRCurrColor, PixelStat.Mean, VarianceGamma * PixelStat.StdDev);\n"
"\n"
"    float Alpha = RGBHDRPrevColor.a * MotionFactor * DepthFactor;\n"
"    float3 RGBHDROutput = SDRToHDR(YCoCgToRGB(lerp(YCoCgSDRCurrColor, YCoCgSDRClampedColor, Alpha)));\n"
"    return float4(RGBHDROutput, ComputeCorrectedAlpha(Alpha));\n"
"}\n"
