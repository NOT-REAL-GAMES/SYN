"#include \"BasicStructures.fxh\"\n"
"#include \"FullScreenTriangleVSOutput.fxh\"\n"
"#include \"PostFX_Common.fxh\"\n"
"\n"
"#define HILBERT_LEVEL 7u\n"
"#define HILBERT_WIDTH (1u << HILBERT_LEVEL)\n"
"\n"
"struct PSOutput\n"
"{\n"
"    float2 BlueNoiseXY : SV_Target0;\n"
"    float2 BlueNoiseZW : SV_Target1;\n"
"};\n"
"\n"
"Texture2D<uint> g_SobolBuffer;\n"
"Texture2D<uint> g_ScramblingTileBuffer;\n"
"\n"
"// Blue Noise Sampler by Eric Heitz. Returns a value in the range [0, 1].\n"
"float SampleRandomNumber(uint2 PixelCoord, uint SampleDimension)\n"
"{\n"
"    // Wrap arguments\n"
"    PixelCoord = PixelCoord & 127u;\n"
"    SampleDimension = SampleDimension & 255u;\n"
"\n"
"    // Fetch value in sequence\n"
"    uint Value = g_SobolBuffer.Load(uint3(SampleDimension, 0, 0));\n"
"\n"
"    // If the dimension is optimized, xor sequence value based on optimized scrambling\n"
"    uint OriginalIndex = (SampleDimension % 8u) + (PixelCoord.x + PixelCoord.y * 128u) * 8u;\n"
"    Value = Value ^ g_ScramblingTileBuffer.Load(uint3(OriginalIndex % 512u, OriginalIndex / 512u, 0)); // TODO: AMD doesn\'t support integer division\n"
"\n"
"    return (float(Value) + 0.5f) / 256.0f;\n"
"}\n"
"\n"
"uint HilbertIndex(uint2 PixelCoord)\n"
"{\n"
"    PixelCoord = PixelCoord & (HILBERT_WIDTH - 1u);\n"
"    uint Index = 0u;\n"
"    for (uint CurLevel = HILBERT_WIDTH / 2u; CurLevel > 0u; CurLevel /= 2u)\n"
"    {\n"
"        uint RegionX = uint((PixelCoord.x & CurLevel) > 0u);\n"
"        uint RegionY = uint((PixelCoord.y & CurLevel) > 0u);\n"
"        Index += CurLevel * CurLevel * ((3u * RegionX) ^ RegionY);\n"
"        if (RegionY == 0u)\n"
"        {\n"
"            if (RegionX == 1u)\n"
"            {\n"
"                PixelCoord.x = uint((HILBERT_WIDTH - 1u)) - PixelCoord.x;\n"
"                PixelCoord.y = uint((HILBERT_WIDTH - 1u)) - PixelCoord.y;\n"
"            }\n"
"\n"
"            uint Temp = PixelCoord.x;\n"
"            PixelCoord.x = PixelCoord.y;\n"
"            PixelCoord.y = Temp;\n"
"        }\n"
"    }\n"
"    return Index;\n"
"}\n"
"\n"
"// Roberts R1 sequence see - https://extremelearning.com.au/unreasonable-effectiveness-of-quasirandom-sequences/\n"
"float2 SampleRandomVector2D(uint2 PixelCoord, uint FrameIndex)\n"
"{\n"
"    float G = 1.61803398875f;\n"
"    float Alpha = 0.5 + rcp(G) * float(FrameIndex & 0xFFu);\n"
"    return float2(\n"
"        frac(SampleRandomNumber(PixelCoord, 0u) + Alpha),\n"
"        frac(SampleRandomNumber(PixelCoord, 1u) + Alpha)\n"
"    );\n"
"}\n"
"\n"
" // R2 sequence - see http://extremelearning.com.au/unreasonable-effectiveness-of-quasirandom-sequences/\n"
"float2 SampleRandomVector1D1D(uint2 PixelCoord, uint FrameIndex)\n"
"{\n"
"    uint Index = (HilbertIndex(PixelCoord) + FrameIndex);\n"
"    Index += 288u * (FrameIndex & (HILBERT_WIDTH - 1u));\n"
"\n"
"    float G = 1.32471795724474602596;\n"
"    float2 Alpha = float2(rcp(G), rcp(G * G));\n"
"    return frac(float2(0.5, 0.5) + float(Index) * Alpha);\n"
"}\n"
"\n"
"PSOutput ComputeBlueNoiseTexturePS(in FullScreenTriangleVSOutput VSOut)\n"
"{\n"
"    uint FrameIndex = VSOut.uInstID;\n"
"\n"
"    PSOutput Output;\n"
"    Output.BlueNoiseXY = SampleRandomVector2D(uint2(VSOut.f4PixelPos.xy), FrameIndex);\n"
"    Output.BlueNoiseZW = SampleRandomVector1D1D(uint2(VSOut.f4PixelPos.xy), FrameIndex);\n"
"    return Output;\n"
"}\n"
