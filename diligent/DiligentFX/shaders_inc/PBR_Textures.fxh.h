"#ifndef _PBR_TEXTURES_FXH_\n"
"#define _PBR_TEXTURES_FXH_\n"
"\n"
"#if USE_TEXTURE_ATLAS\n"
"#   include \"AtlasSampling.fxh\"\n"
"#endif\n"
"\n"
"#ifndef BaseColorTextureAttribId\n"
"#   define BaseColorTextureAttribId 0\n"
"#endif\n"
"\n"
"#ifndef PhysicalDescriptorTextureAttribId\n"
"#   define PhysicalDescriptorTextureAttribId 1\n"
"#endif\n"
"\n"
"#ifndef NormalTextureAttribId\n"
"#   define NormalTextureAttribId 2\n"
"#endif\n"
"\n"
"#ifndef OcclusionTextureAttribId\n"
"#   define OcclusionTextureAttribId 3\n"
"#endif\n"
"\n"
"#ifndef EmissiveTextureAttribId\n"
"#   define EmissiveTextureAttribId 4\n"
"#endif\n"
"\n"
"#if !defined(USE_TEXCOORD0) && !defined(USE_TEXCOORD1)\n"
"#   undef USE_COLOR_MAP\n"
"#   define USE_COLOR_MAP 0\n"
"\n"
"#   undef USE_METALLIC_MAP\n"
"#   define USE_METALLIC_MAP 0\n"
"\n"
"#   undef USE_ROUGHNESS_MAP\n"
"#   define USE_ROUGHNESS_MAP 0\n"
"\n"
"#   undef USE_PHYS_DESC_MAP\n"
"#   define USE_PHYS_DESC_MAP 0\n"
"\n"
"#   undef USE_NORMAL_MAP\n"
"#   define USE_NORMAL_MAP 0\n"
"\n"
"#   undef USE_AO_MAP\n"
"#   define USE_AO_MAP 0\n"
"\n"
"#   undef USE_EMISSIVE_MAP\n"
"#   define USE_EMISSIVE_MAP 0\n"
"\n"
"#   undef USE_CLEAR_COAT_MAP\n"
"#   define USE_CLEAR_COAT_MAP 0\n"
"\n"
"#   undef USE_CLEAR_COAT_ROUGHNESS_MAP\n"
"#   define USE_CLEAR_COAT_ROUGHNESS_MAP 0\n"
"\n"
"#   undef USE_CLEAR_COAT_NORMAL_MAP\n"
"#   define USE_CLEAR_COAT_NORMAL_MAP 0\n"
"\n"
"#   undef USE_SHEEN_COLOR_MAP\n"
"#   define USE_SHEEN_COLOR_MAP 0\n"
"\n"
"#   undef USE_SHEEN_ROUGHNESS_MAP\n"
"#   define USE_SHEEN_ROUGHNESS_MAP 0\n"
"\n"
"#   undef USE_ANISOTROPY_MAP\n"
"#   define USE_ANISOTROPY_MAP 0\n"
"\n"
"#   undef USE_IRIDESCENCE_MAP\n"
"#   define USE_IRIDESCENCE_MAP 0\n"
"\n"
"#   undef USE_IRIDESCENCE_THICKNESS_MAP\n"
"#   define USE_IRIDESCENCE_THICKNESS_MAP 0\n"
"\n"
"#   undef USE_TRANSMISSION_MAP\n"
"#   define USE_TRANSMISSION_MAP 0\n"
"\n"
"#   undef USE_THICKNESS_MAP\n"
"#   define USE_THICKNESS_MAP 0\n"
"#endif\n"
"\n"
"SamplerState g_LinearClampSampler;\n"
"\n"
"#if USE_IBL\n"
"    TextureCube  g_IrradianceMap;\n"
"#   define       g_IrradianceMap_sampler g_LinearClampSampler\n"
"\n"
"    TextureCube  g_PrefilteredEnvMap;\n"
"#   define       g_PrefilteredEnvMap_sampler g_LinearClampSampler\n"
"\n"
"    Texture2D    g_PreintegratedGGX;\n"
"#   define       g_PreintegratedGGX_sampler g_LinearClampSampler\n"
"\n"
"#   if ENABLE_SHEEN\n"
"        Texture2D g_PreintegratedCharlie;\n"
"#       define    g_PreintegratedCharlie_sampler g_LinearClampSampler\n"
"#   endif\n"
"#endif\n"
"\n"
"#if ENABLE_SHEEN\n"
"    Texture2D     g_SheenAlbedoScalingLUT;\n"
"#       define    g_SheenAlbedoScalingLUT_sampler g_LinearClampSampler\n"
"#endif\n"
"\n"
"// Access textures by name:\n"
"//  - g_BaseColorMap\n"
"//  - g_PhysicalDescriptorMap\n"
"//  - g_NormalMap\n"
"//  - ...\n"
"#ifndef PBR_TEXTURE_ARRAY_INDEXING_MODE_NONE\n"
"#   define PBR_TEXTURE_ARRAY_INDEXING_MODE_NONE 0\n"
"#endif\n"
"\n"
"// Access textures using the compile-time static indices:\n"
"//  - g_MaterialTextures[BaseColorTextureId]\n"
"//  - g_MaterialTextures[PhysicalDescriptorTextureId]\n"
"//  - g_MaterialTextures[NormalTextureId]\n"
"//  - ...\n"
"#ifndef PBR_TEXTURE_ARRAY_INDEXING_MODE_STATIC\n"
"#   define PBR_TEXTURE_ARRAY_INDEXING_MODE_STATIC 1\n"
"#endif\n"
"\n"
"// Access textures using the run-time dynamic indices\n"
"#ifndef PBR_TEXTURE_ARRAY_INDEXING_MODE_DYNAMIC\n"
"#   define PBR_TEXTURE_ARRAY_INDEXING_MODE_DYNAMIC 2\n"
"#endif\n"
"\n"
"#ifndef PBR_TEXTURE_ARRAY_INDEXING_MODE\n"
"#   define PBR_TEXTURE_ARRAY_INDEXING_MODE PBR_TEXTURE_ARRAY_INDEXING_MODE_NONE\n"
"#endif\n"
"\n"
"#if PBR_TEXTURE_ARRAY_INDEXING_MODE == PBR_TEXTURE_ARRAY_INDEXING_MODE_NONE\n"
"#   define USE_MATERIAL_TEXTURES_ARRAY 0\n"
"#else\n"
"#   define USE_MATERIAL_TEXTURES_ARRAY 1\n"
"#endif\n"
"\n"
"\n"
"#if USE_MATERIAL_TEXTURES_ARRAY && defined(PBR_NUM_MATERIAL_TEXTURES) && PBR_NUM_MATERIAL_TEXTURES > 0\n"
"    Texture2DArray g_MaterialTextures[PBR_NUM_MATERIAL_TEXTURES];\n"
"#endif\n"
"\n"
"#if PBR_TEXTURE_ARRAY_INDEXING_MODE == PBR_TEXTURE_ARRAY_INDEXING_MODE_DYNAMIC\n"
"// Use TextureSlice as the index into the texture array.\n"
"#   define BaseColorTextureId            Material.Textures[BaseColorTextureAttribId].TextureSlice\n"
"#   define MetallicTextureId             Material.Textures[MetallicTextureAttribId].TextureSlice\n"
"#   define RoughnessTextureId            Material.Textures[RoughnessTextureAttribId].TextureSlice\n"
"#   define PhysicalDescriptorTextureId   Material.Textures[PhysicalDescriptorTextureAttribId].TextureSlice\n"
"#   define NormalTextureId               Material.Textures[NormalTextureAttribId].TextureSlice\n"
"#   define OcclusionTextureId            Material.Textures[OcclusionTextureAttribId].TextureSlice\n"
"#   define EmissiveTextureId             Material.Textures[EmissiveTextureAttribId].TextureSlice\n"
"#   define ClearCoatTextureId            Material.Textures[ClearCoatTextureAttribId].TextureSlice\n"
"#   define ClearCoatRoughnessTextureId   Material.Textures[ClearCoatRoughnessTextureAttribId].TextureSlice\n"
"#   define ClearCoatNormalTextureId      Material.Textures[ClearCoatNormalTextureAttribId].TextureSlice\n"
"#   define SheenColorTextureId           Material.Textures[SheenColorTextureAttribId].TextureSlice\n"
"#   define SheenRoughnessTextureId       Material.Textures[SheenRoughnessTextureAttribId].TextureSlice\n"
"#   define AnisotropyTextureId           Material.Textures[AnisotropyTextureAttribId].TextureSlice\n"
"#   define IridescenceTextureId          Material.Textures[IridescenceTextureAttribId].TextureSlice\n"
"#   define IridescenceThicknessTextureId Material.Textures[IridescenceThicknessTextureAttribId].TextureSlice\n"
"#   define TransmissionTextureId         Material.Textures[TransmissionTextureAttribId].TextureSlice\n"
"#   define ThicknessTextureId            Material.Textures[ThicknessTextureAttribId].TextureSlice\n"
"#endif\n"
"\n"
"#if USE_COLOR_MAP\n"
"#   if USE_MATERIAL_TEXTURES_ARRAY\n"
"#       define g_BaseColorMap g_MaterialTextures[BaseColorTextureId]\n"
"#   else\n"
"        Texture2DArray g_BaseColorMap;\n"
"#   endif\n"
"    SamplerState g_BaseColorMap_sampler;\n"
"#endif\n"
"\n"
"#if USE_METALLIC_MAP\n"
"#   if USE_MATERIAL_TEXTURES_ARRAY\n"
"#       define g_MetallicMap g_MaterialTextures[MetallicTextureId]\n"
"#   else\n"
"        Texture2DArray g_MetallicMap;\n"
"#   endif\n"
"    SamplerState g_MetallicMap_sampler;\n"
"#endif\n"
"\n"
"#if USE_ROUGHNESS_MAP\n"
"#   if USE_MATERIAL_TEXTURES_ARRAY\n"
"#       define g_RoughnessMap g_MaterialTextures[RoughnessTextureId]\n"
"#   else\n"
"        Texture2DArray g_RoughnessMap;\n"
"#   endif\n"
"    SamplerState g_RoughnessMap_sampler;\n"
"#endif\n"
"\n"
"#if USE_PHYS_DESC_MAP\n"
"#   if USE_MATERIAL_TEXTURES_ARRAY\n"
"#       define g_PhysicalDescriptorMap g_MaterialTextures[PhysicalDescriptorTextureId]\n"
"#   else\n"
"        Texture2DArray g_PhysicalDescriptorMap;\n"
"#   endif\n"
"    SamplerState g_PhysicalDescriptorMap_sampler;\n"
"#endif\n"
"\n"
"#if USE_NORMAL_MAP\n"
"#   if USE_MATERIAL_TEXTURES_ARRAY\n"
"#       define g_NormalMap g_MaterialTextures[NormalTextureId]\n"
"#   else\n"
"        Texture2DArray g_NormalMap;\n"
"#   endif\n"
"    SamplerState g_NormalMap_sampler;\n"
"#endif\n"
"\n"
"#if USE_AO_MAP\n"
"#   if USE_MATERIAL_TEXTURES_ARRAY\n"
"#       define g_OcclusionMap g_MaterialTextures[OcclusionTextureId]\n"
"#   else\n"
"        Texture2DArray g_OcclusionMap;\n"
"#   endif\n"
"    SamplerState g_OcclusionMap_sampler;\n"
"#endif\n"
"\n"
"#if USE_EMISSIVE_MAP\n"
"#   if USE_MATERIAL_TEXTURES_ARRAY\n"
"#       define g_EmissiveMap g_MaterialTextures[EmissiveTextureId]\n"
"#   else\n"
"        Texture2DArray g_EmissiveMap;\n"
"#   endif\n"
"    SamplerState g_EmissiveMap_sampler;\n"
"#endif\n"
"\n"
"\n"
"#if USE_CLEAR_COAT_MAP || USE_CLEAR_COAT_ROUGHNESS_MAP || USE_CLEAR_COAT_NORMAL_MAP\n"
"    SamplerState g_ClearCoat_sampler;\n"
"#endif\n"
"\n"
"#if USE_CLEAR_COAT_MAP\n"
"#   if USE_MATERIAL_TEXTURES_ARRAY\n"
"#       define g_ClearCoatMap g_MaterialTextures[ClearCoatTextureId]\n"
"#   else\n"
"        Texture2DArray g_ClearCoatMap;\n"
"#   endif\n"
"#   define g_ClearCoatMap_sampler g_ClearCoat_sampler\n"
"#endif\n"
"\n"
"#if USE_CLEAR_COAT_ROUGHNESS_MAP\n"
"#   if USE_MATERIAL_TEXTURES_ARRAY\n"
"#       define g_ClearCoatRoughnessMap g_MaterialTextures[ClearCoatRoughnessTextureId]\n"
"#   else\n"
"        Texture2DArray g_ClearCoatRoughnessMap;\n"
"#   endif\n"
"#   define g_ClearCoatRoughnessMap_sampler g_ClearCoat_sampler\n"
"#endif\n"
"\n"
"#if USE_CLEAR_COAT_NORMAL_MAP\n"
"#   if USE_MATERIAL_TEXTURES_ARRAY\n"
"#       define g_ClearCoatNormalMap g_MaterialTextures[ClearCoatNormalTextureId]\n"
"#   else\n"
"        Texture2DArray g_ClearCoatNormalMap;\n"
"#   endif\n"
"#   define g_ClearCoatNormalMap_sampler g_ClearCoat_sampler\n"
"#endif\n"
"\n"
"\n"
"#if USE_SHEEN_COLOR_MAP || USE_SHEEN_ROUGHNESS_MAP\n"
"    SamplerState g_Sheen_sampler;\n"
"#endif\n"
"\n"
"#if USE_SHEEN_COLOR_MAP\n"
"#   if USE_MATERIAL_TEXTURES_ARRAY\n"
"#       define g_SheenColorMap g_MaterialTextures[SheenColorTextureId]\n"
"#   else\n"
"        Texture2DArray g_SheenColorMap;\n"
"#   endif\n"
"#   define g_SheenColorMap_sampler g_Sheen_sampler\n"
"#endif\n"
"\n"
"#if USE_SHEEN_ROUGHNESS_MAP\n"
"#   if USE_MATERIAL_TEXTURES_ARRAY\n"
"#       define g_SheenRoughnessMap g_MaterialTextures[SheenRoughnessTextureId]\n"
"#   else\n"
"        Texture2DArray g_SheenRoughnessMap;\n"
"#   endif\n"
"#   define g_SheenRoughnessMap_sampler g_Sheen_sampler\n"
"#endif\n"
"\n"
"#if USE_ANISOTROPY_MAP\n"
"#   if USE_MATERIAL_TEXTURES_ARRAY\n"
"#       define g_AnisotropyMap g_MaterialTextures[AnisotropyTextureId]\n"
"#   else\n"
"        Texture2DArray g_AnisotropyMap;\n"
"#   endif\n"
"    SamplerState g_AnisotropyMap_sampler;\n"
"#endif\n"
"\n"
"#if USE_IRIDESCENCE_MAP || USE_IRIDESCENCE_THICKNESS_MAP\n"
"    SamplerState g_Iridescence_sampler;\n"
"#endif\n"
"\n"
"#if USE_IRIDESCENCE_MAP\n"
"#   if USE_MATERIAL_TEXTURES_ARRAY\n"
"#       define g_IridescenceMap g_MaterialTextures[IridescenceTextureId]\n"
"#   else\n"
"        Texture2DArray g_IridescenceMap;\n"
"#   endif\n"
"#   define g_IridescenceMap_sampler g_Iridescence_sampler\n"
"#endif\n"
"\n"
"#if USE_IRIDESCENCE_THICKNESS_MAP\n"
"#   if USE_MATERIAL_TEXTURES_ARRAY\n"
"#       define g_IridescenceThicknessMap g_MaterialTextures[IridescenceThicknessTextureId]\n"
"#   else\n"
"        Texture2DArray g_IridescenceThicknessMap;\n"
"#   endif\n"
"#   define g_IridescenceThicknessMap_sampler g_Iridescence_sampler\n"
"#endif\n"
"\n"
"#if USE_TRANSMISSION_MAP\n"
"#   if USE_MATERIAL_TEXTURES_ARRAY\n"
"#       define g_TransmissionMap g_MaterialTextures[TransmissionTextureId]\n"
"#   else\n"
"        Texture2DArray g_TransmissionMap;\n"
"#   endif\n"
"    SamplerState g_TransmissionMap_sampler;\n"
"#endif\n"
"\n"
"#if USE_THICKNESS_MAP\n"
"#   if USE_MATERIAL_TEXTURES_ARRAY\n"
"#       define g_ThicknessMap g_MaterialTextures[ThicknessTextureId]\n"
"#   else\n"
"        Texture2DArray g_ThicknessMap;\n"
"#   endif\n"
"    SamplerState g_ThicknessMap_sampler;\n"
"#endif\n"
"\n"
"float2 SelectUV(VSOutput VSOut, float Selector)\n"
"{\n"
"#if USE_TEXCOORD0 && USE_TEXCOORD1\n"
"    return lerp(VSOut.UV0, VSOut.UV1, Selector);\n"
"#elif USE_TEXCOORD0\n"
"    return VSOut.UV0;\n"
"#elif USE_TEXCOORD1\n"
"    return VSOut.UV1;\n"
"#else\n"
"    return float2(0.0, 0.0);\n"
"#endif\n"
"}\n"
"\n"
"float2 TransformUV(float2 UV, PBRMaterialTextureAttribs TexAttribs)\n"
"{\n"
"    return mul(UV, MatrixFromRows(TexAttribs.UVScaleAndRotation.xy, TexAttribs.UVScaleAndRotation.zw)) + float2(TexAttribs.UBias, TexAttribs.VBias);\n"
"}\n"
"\n"
"float4 SampleTexture(Texture2DArray            Tex,\n"
"                     SamplerState              Tex_sampler,\n"
"                     VSOutput                  VSOut,\n"
"                     PBRMaterialTextureAttribs TexAttribs,\n"
"                     float                     MipBias,\n"
"                     float4                    DefaultValue)\n"
"{\n"
"    if (TexAttribs.UVSelector < 0.0)\n"
"    {\n"
"        return DefaultValue;\n"
"    }\n"
"\n"
"#   if USE_TEXCOORD0 || USE_TEXCOORD1\n"
"    {\n"
"        float2 UV = SelectUV(VSOut, TexAttribs.UVSelector);\n"
"#       if ENABLE_TEXCOORD_TRANSFORM\n"
"        {\n"
"            UV = TransformUV(UV, TexAttribs);\n"
"        }\n"
"#       endif\n"
"\n"
"#       if USE_TEXTURE_ATLAS\n"
"        {\n"
"            float GradientScale = exp2(MipBias);\n"
"\n"
"            SampleTextureAtlasAttribs SampleAttribs;\n"
"            SampleAttribs.f2UV                   = frac(UV) * TexAttribs.AtlasUVScaleAndBias.xy + TexAttribs.AtlasUVScaleAndBias.zw;\n"
"            SampleAttribs.f2SmoothUV             = UV      * TexAttribs.AtlasUVScaleAndBias.xy * GradientScale;\n"
"            SampleAttribs.f2dSmoothUV_dx         = ddx(UV) * TexAttribs.AtlasUVScaleAndBias.xy * GradientScale;\n"
"            SampleAttribs.f2dSmoothUV_dy         = ddy(UV) * TexAttribs.AtlasUVScaleAndBias.xy * GradientScale;\n"
"            SampleAttribs.fSlice                 = TexAttribs.TextureSlice;\n"
"            SampleAttribs.f4UVRegion             = TexAttribs.AtlasUVScaleAndBias;\n"
"            SampleAttribs.fSmallestValidLevelDim = 4.0;\n"
"            SampleAttribs.IsNonFilterable        = false;\n"
"            SampleAttribs.fMaxAnisotropy         = 1.0; // Only used on GLES\n"
"            return SampleTextureAtlas(Tex, Tex_sampler, SampleAttribs);\n"
"        }\n"
"#       else\n"
"        {\n"
"            return Tex.SampleBias(Tex_sampler, float3(UV, TexAttribs.TextureSlice), MipBias);\n"
"        }\n"
"#       endif\n"
"    }\n"
"#   else\n"
"    {\n"
"        return DefaultValue;\n"
"    }\n"
"#   endif\n"
"}\n"
"\n"
"float4 GetBaseColor(VSOutput              VSOut,\n"
"                    PBRMaterialShaderInfo Material,\n"
"                    float                 MipBias)\n"
"{\n"
"    float4 BaseColor = float4(1.0, 1.0, 1.0, 1.0);\n"
"\n"
"#   if USE_COLOR_MAP\n"
"    {\n"
"        BaseColor = SampleTexture(g_BaseColorMap,\n"
"                                  g_BaseColorMap_sampler,\n"
"                                  VSOut,\n"
"                                  Material.Textures[BaseColorTextureAttribId],\n"
"                                  MipBias,\n"
"                                  float4(1.0, 1.0, 1.0, 1.0));\n"
"        BaseColor = float4(TO_LINEAR(BaseColor.rgb), BaseColor.a);\n"
"    }\n"
"#   endif\n"
"\n"
"#   if USE_VERTEX_COLORS\n"
"    {\n"
"        BaseColor *= VSOut.Color;\n"
"    }\n"
"#   endif\n"
"\n"
"    return BaseColor * Material.Basic.BaseColorFactor;\n"
"}\n"
"\n"
"float3 SampleNormalTexture(PBRMaterialTextureAttribs TexAttribs,\n"
"                           Texture2DArray            NormalMap,\n"
"                           SamplerState              NormalMap_sampler,\n"
"                           float2                    NormalMapUV,\n"
"                           float2                    SmoothNormalMapUV,\n"
"                           float2                    dNormalMapUV_dx,\n"
"                           float2                    dNormalMapUV_dy,\n"
"                           float                     MipBias)\n"
"{\n"
"    if (TexAttribs.UVSelector < 0.0)\n"
"    {\n"
"        return float3(0.5, 0.5, 1.0);\n"
"    }\n"
"\n"
"#   if USE_TEXTURE_ATLAS\n"
"    {\n"
"        float GradientScale = exp2(MipBias);\n"
"\n"
"        SampleTextureAtlasAttribs SampleAttribs;\n"
"        SampleAttribs.f2UV                   = NormalMapUV;\n"
"        SampleAttribs.f2SmoothUV             = SmoothNormalMapUV * GradientScale;\n"
"        SampleAttribs.f2dSmoothUV_dx         = dNormalMapUV_dx   * GradientScale;\n"
"        SampleAttribs.f2dSmoothUV_dy         = dNormalMapUV_dy   * GradientScale;\n"
"        SampleAttribs.fSlice                 = TexAttribs.TextureSlice;\n"
"        SampleAttribs.f4UVRegion             = TexAttribs.AtlasUVScaleAndBias;\n"
"        SampleAttribs.fSmallestValidLevelDim = 4.0;\n"
"        SampleAttribs.IsNonFilterable        = false;\n"
"        SampleAttribs.fMaxAnisotropy         = 1.0; // Only used on GLES\n"
"        return SampleTextureAtlas(NormalMap, NormalMap_sampler, SampleAttribs).xyz;\n"
"    }\n"
"#   else\n"
"    {\n"
"        return NormalMap.SampleBias(NormalMap_sampler, float3(NormalMapUV, TexAttribs.TextureSlice), MipBias).xyz;\n"
"    }\n"
"#   endif\n"
"}\n"
"\n"
"float3 GetMicroNormal(PBRMaterialShaderInfo Material,\n"
"                      float2                NormalMapUV,\n"
"                      float2                SmoothNormalMapUV,\n"
"                      float2                dNormalMapUV_dx,\n"
"                      float2                dNormalMapUV_dy,\n"
"                      float                 MipBias)\n"
"{\n"
"    float3 MicroNormal = float3(0.5, 0.5, 1.0);\n"
"\n"
"#   if USE_NORMAL_MAP && (USE_TEXCOORD0 || USE_TEXCOORD1)\n"
"    {\n"
"        MicroNormal = SampleNormalTexture(Material.Textures[NormalTextureAttribId],\n"
"                                          g_NormalMap,\n"
"                                          g_NormalMap_sampler,\n"
"                                          NormalMapUV,\n"
"                                          SmoothNormalMapUV,\n"
"                                          dNormalMapUV_dx,\n"
"                                          dNormalMapUV_dy,\n"
"                                          MipBias);\n"
"    }\n"
"#endif\n"
"\n"
"    return MicroNormal * float3(2.0, 2.0, 2.0) - float3(1.0, 1.0, 1.0);\n"
"}\n"
"\n"
"float GetOcclusion(VSOutput              VSOut,\n"
"                   PBRMaterialShaderInfo Material,\n"
"                   float                 MipBias)\n"
"{\n"
"    float Occlusion = 1.0;\n"
"#   if USE_AO_MAP\n"
"    {\n"
"        Occlusion = SampleTexture(g_OcclusionMap,\n"
"                                  g_OcclusionMap_sampler,\n"
"                                  VSOut,\n"
"                                  Material.Textures[OcclusionTextureAttribId],\n"
"                                  MipBias,\n"
"                                  float4(1.0, 1.0, 1.0, 1.0)).r;\n"
"    }\n"
"#   endif\n"
"    return Occlusion * Material.Basic.OcclusionFactor;\n"
"}\n"
"\n"
"float3 GetEmissive(VSOutput              VSOut,\n"
"                   PBRMaterialShaderInfo Material,\n"
"                   float                 MipBias)\n"
"{\n"
"    float3 Emissive = float3(1.0, 1.0, 1.0);\n"
"#   if USE_EMISSIVE_MAP\n"
"    {\n"
"        Emissive = SampleTexture(g_EmissiveMap,\n"
"                                 g_EmissiveMap_sampler,\n"
"                                 VSOut,\n"
"                                 Material.Textures[EmissiveTextureAttribId],\n"
"                                 MipBias,\n"
"                                 float4(1.0, 1.0, 1.0, 1.0)).rgb;\n"
"        Emissive = TO_LINEAR(Emissive);\n"
"    }\n"
"#   endif\n"
"    return Emissive * Material.Basic.EmissiveFactor.rgb;\n"
"}\n"
"\n"
"float4 GetPhysicalDesc(VSOutput              VSOut,\n"
"                       PBRMaterialShaderInfo Material,\n"
"                       float                 MipBias)\n"
"{\n"
"    // Set defaults to 1 so that if the textures are not available, the values\n"
"    // are controlled by the metallic/roughness scale factors.\n"
"    float4 PhysicalDesc = float4(1.0, 1.0, 1.0, 1.0);\n"
"#   if USE_PHYS_DESC_MAP\n"
"    {\n"
"        PhysicalDesc = SampleTexture(g_PhysicalDescriptorMap,\n"
"                                     g_PhysicalDescriptorMap_sampler,\n"
"                                     VSOut,\n"
"                                     Material.Textures[PhysicalDescriptorTextureAttribId],\n"
"                                     MipBias,\n"
"                                     float4(1.0, 1.0, 1.0, 1.0));\n"
"    }\n"
"#   else\n"
"    {\n"
"#       if USE_METALLIC_MAP\n"
"        {\n"
"            PhysicalDesc.b = SampleTexture(g_MetallicMap,\n"
"                                           g_MetallicMap_sampler,\n"
"                                           VSOut,\n"
"                                           Material.Textures[MetallicTextureAttribId],\n"
"                                           MipBias,\n"
"                                           float4(1.0, 1.0, 1.0, 1.0)).r;\n"
"        }\n"
"#       endif\n"
"\n"
"#       if USE_ROUGHNESS_MAP\n"
"        {\n"
"            PhysicalDesc.g = SampleTexture(g_RoughnessMap,\n"
"                                           g_RoughnessMap_sampler,\n"
"                                           VSOut,\n"
"                                           Material.Textures[RoughnessTextureAttribId],\n"
"                                           MipBias,\n"
"                                           float4(1.0, 1.0, 1.0, 1.0)).r;\n"
"\n"
"        }\n"
"#       endif\n"
"    }\n"
"#endif\n"
"\n"
"    return PhysicalDesc;\n"
"}\n"
"\n"
"\n"
"// Extensions\n"
"\n"
"// Clear coat\n"
"// https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_materials_clearcoat\n"
"\n"
"float GetClearcoatFactor(VSOutput              VSOut,\n"
"                         PBRMaterialShaderInfo Material,\n"
"                         float                 MipBias)\n"
"{\n"
"#   if ENABLE_CLEAR_COAT\n"
"    {\n"
"        float Cearcoat = 1.0;\n"
"#       if USE_CLEAR_COAT_MAP\n"
"        {\n"
"            Cearcoat = SampleTexture(g_ClearCoatMap,\n"
"                                     g_ClearCoatMap_sampler,\n"
"                                     VSOut,\n"
"                                     Material.Textures[ClearCoatTextureAttribId],\n"
"                                     MipBias,\n"
"                                     float4(1.0, 1.0, 1.0, 1.0)).r;\n"
"        }\n"
"#       endif\n"
"        return Cearcoat * Material.Basic.ClearcoatFactor;\n"
"    }\n"
"#   else\n"
"    {\n"
"        return 0.0;\n"
"    }\n"
"#   endif\n"
"}\n"
"\n"
"float GetClearcoatRoughness(VSOutput              VSOut,\n"
"                            PBRMaterialShaderInfo Material,\n"
"                            float                 MipBias)\n"
"{\n"
"#   if ENABLE_CLEAR_COAT\n"
"    {\n"
"        float CearcoatRoughness = 1.0;\n"
"#       if USE_CLEAR_COAT_ROUGHNESS_MAP\n"
"        {\n"
"            CearcoatRoughness = SampleTexture(g_ClearCoatRoughnessMap,\n"
"                                              g_ClearCoatRoughnessMap_sampler,\n"
"                                              VSOut,\n"
"                                              Material.Textures[ClearCoatRoughnessTextureAttribId],\n"
"                                              MipBias,\n"
"                                              float4(1.0, 1.0, 1.0, 1.0)).g;\n"
"        }\n"
"#       endif\n"
"        return CearcoatRoughness * Material.Basic.ClearcoatRoughnessFactor;\n"
"    }\n"
"#   else\n"
"    {\n"
"        return 0.0;\n"
"    }\n"
"#   endif\n"
"}\n"
"\n"
"float3 GetClearcoatNormal(PBRMaterialShaderInfo Material,\n"
"                          float2                NormalMapUV,\n"
"                          float2                SmoothNormalMapUV,\n"
"                          float2                dNormalMapUV_dx,\n"
"                          float2                dNormalMapUV_dy,\n"
"                          float                 MipBias)\n"
"{\n"
"    float3 ClearcoatNormal = float3(0.5, 0.5, 1.0);\n"
"#   if ENABLE_CLEAR_COAT\n"
"    {\n"
"#       if USE_CLEAR_COAT_NORMAL_MAP\n"
"        {\n"
"            ClearcoatNormal =\n"
"                SampleNormalTexture(Material.Textures[ClearCoatNormalTextureAttribId],\n"
"                                    g_ClearCoatNormalMap,\n"
"                                    g_ClearCoatNormalMap_sampler,\n"
"                                    NormalMapUV,\n"
"                                    SmoothNormalMapUV,\n"
"                                    dNormalMapUV_dx,\n"
"                                    dNormalMapUV_dy,\n"
"                                    MipBias);\n"
"        }\n"
"#       endif\n"
"    }\n"
"#endif\n"
"    return ClearcoatNormal * float3(2.0, 2.0, 2.0) - float3(1.0, 1.0, 1.0);\n"
"}\n"
"\n"
"\n"
"// Sheen\n"
"// https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_materials_sheen\n"
"\n"
"float3 GetSheenColor(VSOutput              VSOut,\n"
"                     PBRMaterialShaderInfo Material,\n"
"                     float                 MipBias)\n"
"{\n"
"#   if ENABLE_SHEEN\n"
"    {\n"
"        float3 SheenColor = float3(1.0, 1.0, 1.0);\n"
"#       if USE_SHEEN_COLOR_MAP\n"
"        {\n"
"            SheenColor = SampleTexture(g_SheenColorMap,\n"
"                                       g_SheenColorMap_sampler,\n"
"                                       VSOut,\n"
"                                       Material.Textures[SheenColorTextureAttribId],\n"
"                                       MipBias,\n"
"                                       float4(1.0, 1.0, 1.0, 1.0)).rgb;\n"
"            SheenColor = TO_LINEAR(SheenColor);\n"
"        }\n"
"#       endif\n"
"        return SheenColor * float3(Material.Sheen.ColorFactorR, Material.Sheen.ColorFactorG, Material.Sheen.ColorFactorB);\n"
"    }\n"
"#   else\n"
"    {\n"
"        return float3(0.0, 0.0, 0.0);\n"
"    }\n"
"#endif\n"
"}\n"
"\n"
"float GetSheenRoughness(VSOutput              VSOut,\n"
"                        PBRMaterialShaderInfo Material,\n"
"                        float                 MipBias)\n"
"{\n"
"#   if ENABLE_SHEEN\n"
"    {\n"
"        float SheenRoughness = 1.0;\n"
"#       if USE_SHEEN_ROUGHNESS_MAP\n"
"        {\n"
"            SheenRoughness = SampleTexture(g_SheenRoughnessMap,\n"
"                                           g_SheenRoughnessMap_sampler,\n"
"                                           VSOut,\n"
"                                           Material.Textures[SheenRoughnessTextureAttribId],\n"
"                                           MipBias,\n"
"                                           float4(1.0, 1.0, 1.0, 1.0)).a;\n"
"        }\n"
"#       endif\n"
"        return SheenRoughness * Material.Sheen.RoughnessFactor;\n"
"    }\n"
"#   else\n"
"    {\n"
"        return 0.0;\n"
"    }\n"
"#   endif\n"
"}\n"
"\n"
"\n"
"// Anisotropy\n"
"// https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_materials_anisotropy\n"
"\n"
"float3 GetAnisotropy(VSOutput              VSOut,\n"
"                     PBRMaterialShaderInfo Material,\n"
"                     float                 MipBias)\n"
"{\n"
"#   if ENABLE_ANISOTROPY\n"
"    {\n"
"        // Default anisotropy direction is (1, 0) and default strength is 1.0.\n"
"        float3 Anisotropy = float3(1.0, 0.5, 1.0);\n"
"#       if USE_ANISOTROPY_MAP\n"
"        {\n"
"            Anisotropy = SampleTexture(g_AnisotropyMap,\n"
"                                       g_AnisotropyMap_sampler,\n"
"                                       VSOut,\n"
"                                       Material.Textures[AnisotropyTextureAttribId],\n"
"                                       MipBias,\n"
"                                       float4(Anisotropy, 1.0)).rgb;\n"
"        }\n"
"#       endif\n"
"        Anisotropy.xy = Anisotropy.xy * 2.0 - 1.0;\n"
"        Anisotropy.z *= Material.Anisotropy.Strength;\n"
"        return Anisotropy;\n"
"    }\n"
"#   else\n"
"    {\n"
"        return float3(0.0, 0.0, 0.0);\n"
"    }\n"
"#endif\n"
"}\n"
"\n"
"\n"
"// Iridescence\n"
"// https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_materials_iridescence\n"
"\n"
"float GetIridescence(VSOutput              VSOut,\n"
"                     PBRMaterialShaderInfo Material,\n"
"                     float                 MipBias)\n"
"{\n"
"#   if ENABLE_IRIDESCENCE\n"
"    {\n"
"        float Iridescence = 1.0;\n"
"#       if USE_IRIDESCENCE_MAP\n"
"        {\n"
"            Iridescence = SampleTexture(g_IridescenceMap,\n"
"                                        g_IridescenceMap_sampler,\n"
"                                        VSOut,\n"
"                                        Material.Textures[IridescenceTextureAttribId],\n"
"                                        MipBias,\n"
"                                        float4(1.0, 1.0, 1.0, 1.0)).r;\n"
"        }\n"
"#       endif\n"
"        return Iridescence * Material.Iridescence.Factor;\n"
"    }\n"
"#   else\n"
"    {\n"
"        return 0.0;\n"
"    }\n"
"#   endif\n"
"}\n"
"\n"
"\n"
"float GetIridescenceThickness(VSOutput              VSOut,\n"
"                              PBRMaterialShaderInfo Material,\n"
"                              float                 MipBias)\n"
"{\n"
"#   if ENABLE_IRIDESCENCE\n"
"    {\n"
"        float Thickness = 1.0;\n"
"#       if USE_IRIDESCENCE_THICKNESS_MAP\n"
"        {\n"
"            Thickness = SampleTexture(g_IridescenceThicknessMap,\n"
"                                      g_IridescenceThicknessMap_sampler,\n"
"                                      VSOut,\n"
"                                      Material.Textures[IridescenceThicknessTextureAttribId],\n"
"                                      MipBias,\n"
"                                      float4(1.0, 1.0, 1.0, 1.0)).g;\n"
"        }\n"
"#       endif\n"
"        return lerp(Material.Iridescence.ThicknessMinimum, Material.Iridescence.ThicknessMaximum, Thickness);\n"
"    }\n"
"#   else\n"
"    {\n"
"        return 0.0;\n"
"    }\n"
"#   endif\n"
"}\n"
"\n"
"\n"
"// Transmission\n"
"// https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_materials_transmission\n"
"\n"
"float GetTransmission(VSOutput              VSOut,\n"
"                      PBRMaterialShaderInfo Material,\n"
"                      float                 MipBias)\n"
"{\n"
"#   if ENABLE_TRANSMISSION\n"
"    {\n"
"        float Transmission = 1.0;\n"
"#       if USE_TRANSMISSION_MAP\n"
"        {\n"
"            Transmission = SampleTexture(g_TransmissionMap,\n"
"                                         g_TransmissionMap_sampler,\n"
"                                         VSOut,\n"
"                                         Material.Textures[TransmissionTextureAttribId],\n"
"                                         MipBias,\n"
"                                         float4(1.0, 1.0, 1.0, 1.0)).r;\n"
"        }\n"
"#       endif\n"
"        return Transmission * Material.Transmission.Factor;\n"
"    }\n"
"#   else\n"
"    {\n"
"        return 0.0;\n"
"    }\n"
"#   endif\n"
"}\n"
"\n"
"\n"
"// Volume\n"
"// https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_materials_volume\n"
"\n"
"float GetVolumeThickness(VSOutput              VSOut,\n"
"                         PBRMaterialShaderInfo Material,\n"
"                         float                 MipBias)\n"
"{\n"
"#   if ENABLE_VOLUME\n"
"    {\n"
"        float Thickness = 1.0;\n"
"#       if USE_THICKNESS_MAP\n"
"        {\n"
"            Thickness = SampleTexture(g_ThicknessMap,\n"
"                                      g_ThicknessMap_sampler,\n"
"                                      VSOut,\n"
"                                      Material.Textures[ThicknessTextureAttribId],\n"
"                                      MipBias,\n"
"                                      float4(1.0, 1.0, 1.0, 1.0)).g;\n"
"        }\n"
"#       endif\n"
"        return Thickness * Material.Volume.ThicknessFactor;\n"
"    }\n"
"#   else\n"
"    {\n"
"        return 0.0;\n"
"    }\n"
"#   endif\n"
"}\n"
"\n"
"#endif // _PBR_TEXTURES_FXH_\n"
