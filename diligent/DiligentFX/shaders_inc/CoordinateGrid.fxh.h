"#ifndef _COORDINATE_GRID_FXH_\n"
"#define _COORDINATE_GRID_FXH_\n"
"\n"
"#include \"CoordinateGridStructures.fxh\"\n"
"#include \"ShaderUtilities.fxh\"\n"
"\n"
"#if COORDINATE_GRID_INVERTED_DEPTH\n"
"    #define DepthNearPlane     1.0\n"
"    #define DepthFarPlane      0.0\n"
"    #define DepthMin           max\n"
"    #define DepthCompare(x, y) ((x)>(y))\n"
"#else\n"
"    #define DepthNearPlane     0.0\n"
"    #define DepthFarPlane      1.0\n"
"    #define DepthMin           min\n"
"    #define DepthCompare(x, y) ((x)<(y))\n"
"#endif // COORDINATE_GRID_INVERTED_DEPTH\n"
"\n"
"struct Ray\n"
"{\n"
"    float3 Origin;\n"
"    float3 Direction;\n"
"};\n"
"\n"
"Ray CreateCameraRay(float2   NormalizedXY,\n"
"                    float4x4 CameraViewProjInv,\n"
"                    float3   CameraPosition)\n"
"{\n"
"    Ray CameraRay;\n"
"    float4 RayStart = mul(float4(NormalizedXY, DepthToNormalizedDeviceZ(DepthNearPlane), 1.0f), CameraViewProjInv);\n"
"    float4 RayEnd   = mul(float4(NormalizedXY, DepthToNormalizedDeviceZ(DepthFarPlane),  1.0f), CameraViewProjInv);\n"
"\n"
"    RayStart.xyz /= RayStart.w;\n"
"    RayEnd.xyz   /= RayEnd.w;\n"
"    CameraRay.Direction = normalize(RayEnd.xyz - RayStart.xyz);\n"
"    CameraRay.Origin    = CameraPosition;\n"
"    return CameraRay;\n"
"}\n"
"\n"
"float ComputeRayPlaneIntersection(Ray RayWS, float3 PlaneNormal, float3 PlaneOrigin)\n"
"{\n"
"    float NdotD = dot(RayWS.Direction, PlaneNormal);\n"
"    NdotD = max(abs(NdotD), 1e-6) * (NdotD > 0.0 ? +1.0 : -1.0);\n"
"    return dot(PlaneNormal, (PlaneOrigin - RayWS.Origin)) / NdotD;\n"
"}\n"
"\n"
"float MinComponent2(float2 v)\n"
"{\n"
"    return min(v.x, v.y);\n"
"}\n"
"\n"
"float MaxComponent2(float2 v)\n"
"{\n"
"    return max(v.x, v.y);\n"
"}\n"
"\n"
"float4 ComputeGrid(float2 PlanePos, float Scale, float Subdivision, CoordinateGridAttribs GridAttribs)\n"
"{\n"
"    float2 Coord = PlanePos * Scale;\n"
"    float2 Magnitude = fwidth(Coord);\n"
"\n"
"    float3 ThickColor = GridAttribs.GridMajorColor.xyz;\n"
"    float3 ThinColor  = GridAttribs.GridMinorColor.xyz;\n"
"    float2 LineWidth = 0.5 * Magnitude * GridAttribs.GridLineWidth;\n"
"\n"
"    float LodLevel = max(0.0, log10(length(Magnitude) * GridAttribs.GridMinCellWidth / GridAttribs.GridMinCellSize) + 1.0);\n"
"    float LodFade = frac(LodLevel);\n"
"\n"
"    float Lod[3];\n"
"    Lod[0] = GridAttribs.GridMinCellSize * pow(Subdivision, floor(LodLevel));\n"
"    Lod[1] = Lod[0] * Subdivision;\n"
"    Lod[2] = Lod[1] * Subdivision;\n"
"\n"
"    float LodAlpha[3];\n"
"    for (int LodIdx = 0; LodIdx < 3; LodIdx++)\n"
"        LodAlpha[LodIdx] = MaxComponent2(float2(1.0, 1.0) - saturate(abs((fmod(abs(Coord - 0.5 * Lod[LodIdx]), Lod[LodIdx]) - 0.5 * Lod[LodIdx]) / LineWidth)));\n"
"\n"
"    return float4(LodAlpha[2] > 0.0 ? ThickColor  : LodAlpha[1] > 0.0 ? lerp(ThickColor, ThinColor, LodFade) : ThinColor,\n"
"                  LodAlpha[2] > 0.0 ? LodAlpha[2] : LodAlpha[1] > 0.0 ? LodAlpha[1] : LodAlpha[0] * (1.0 - LodFade));\n"
"}\n"
"\n"
"float ComputeAxisAlpha(float3   AxisDirection,\n"
"                       Ray      ViewRay,\n"
"                       float    AxisLen,\n"
"                       float    PixelSize,\n"
"                       float    MaxCameraZ,\n"
"                       float    CameraZRange,\n"
"                       float4x4 CameraView)\n"
"{\n"
"    float3 AxisOrigin = float3(0.0, 0.0, 0.0);\n"
"\n"
"    float3 Cross = cross(AxisDirection, ViewRay.Direction);\n"
"    float3 Delta = ViewRay.Origin - AxisOrigin;\n"
"    float  Denom = dot(Cross, Cross);\n"
"    if (abs(Denom) < 1e-7)\n"
"        return 0.0;\n"
"\n"
"    // Distance from the camera to the point on the camera ray that is closest to the axis ray\n"
"    float DistFromCamera = dot(cross(Delta, AxisDirection), Cross) / Denom;\n"
"    if (DistFromCamera < 0.0)\n"
"    {\n"
"        // Closest point is behind the camera\n"
"        return 0.0;\n"
"    }\n"
"\n"
"    // Distance from the origin of the axis to the point on the axis ray that is closest to the camera ray\n"
"    float DistFromOrigin = dot(cross(Delta, ViewRay.Direction), Cross) / Denom;\n"
"    // Point on the axis ray that is closest to the camera ray\n"
"    float3 AxisPos = AxisOrigin + AxisDirection * DistFromOrigin;\n"
"\n"
"    // Shortest distance between the axis and the view ray\n"
"    float  DistToAxis = abs(dot(Delta, Cross)) / max(length(Cross), 0.001);\n"
"\n"
"    // Axis width in world space\n"
"    float AxisWidth = PixelSize * DistFromCamera;\n"
"    float Line = abs(DistToAxis) / AxisWidth;\n"
"    float Alpha = (1.0 - min(Line * Line, 1.0)) * saturate(1.0 - DistFromCamera/AxisLen);\n"
"\n"
"    float AxisPosZ = mul(float4(AxisPos, 1.0), CameraView).z;\n"
"    // Move the point along the view direction to alleviate z-fighting with the geometry\n"
"    AxisPosZ += AxisWidth;\n"
"    // Compute smooth visibility\n"
"    // Note: using minimum depth when TAA is enabled looks bad from the distance\n"
"    //       when there is small geometry (e.g. bicycle while spokes)\n"
"    float Visibility = saturate((MaxCameraZ - AxisPosZ) / CameraZRange);\n"
"    Alpha *= Visibility;\n"
"\n"
"    // Make axis fade out when looking straight along it\n"
"    Alpha *= saturate((1.0 - abs(dot(normalize(ViewRay.Origin), AxisDirection))) * 1e+6);\n"
"\n"
"    return Alpha;\n"
"}\n"
"\n"
"void ComputePlaneIntersectionAttribs(in CameraAttribs Camera,\n"
"                                     in Ray           RayWS,\n"
"                                     in float3        Normal,\n"
"                                     in float         MaxCameraZ,\n"
"                                     in float         CameraZRange,\n"
"                                     out float3       Position,\n"
"                                     out float        Alpha)\n"
"{\n"
"    float DistToPlane = ComputeRayPlaneIntersection(RayWS, Normal, float3(0.0, 0.0, 0.0));\n"
"    Alpha = DistToPlane > 0.0 ? 1.0 : 0.0;\n"
"\n"
"    Position = RayWS.Origin + RayWS.Direction * DistToPlane;\n"
"    float CameraZ = mul(float4(Position, 1.0), Camera.mView).z;\n"
"\n"
"    // Note: using minimum depth when TAA is enabled looks bad from the distance\n"
"    //       when there is small geometry (e.g. bicycle while spokes)\n"
"    // Add bias to avoid z-fighting with geometry in the plane\n"
"    float Visibility = saturate((MaxCameraZ - CameraZ) / CameraZRange + 0.1);\n"
"    Alpha *= Visibility;\n"
"\n"
"    // Attenuate alpha based on the CameraZ to make the grid fade out in the distance\n"
"    Alpha *= saturate(1.0 - CameraZ / Camera.fFarPlaneZ);\n"
"}\n"
"\n"
"float4 ComputeCoordinateGrid(in float2                f2NormalizedXY,\n"
"                             in CameraAttribs         Camera,\n"
"                             in float                 MinDepth,\n"
"                             in float                 MaxDepth,\n"
"                             in CoordinateGridAttribs GridAttribs)\n"
"{\n"
"    Ray RayWS = CreateCameraRay(f2NormalizedXY, Camera.mViewProjInv, Camera.f4Position.xyz);\n"
"\n"
"    float3 Positions[3];\n"
"    float  PlaneAlpha[3];\n"
"\n"
"    float PixelSize = length(Camera.f4ViewportSize.zw);\n"
"    float MinCameraZ = DepthToCameraZ(MinDepth, Camera.mProj);\n"
"    float MaxCameraZ = DepthToCameraZ(MaxDepth, Camera.mProj);\n"
"    float CameraZRange = max(MaxCameraZ - MinCameraZ, 1e-6);\n"
"\n"
"    ComputePlaneIntersectionAttribs(Camera, RayWS, float3(1.0, 0.0, 0.0), MaxCameraZ, CameraZRange, Positions[0], PlaneAlpha[0]);\n"
"    ComputePlaneIntersectionAttribs(Camera, RayWS, float3(0.0, 1.0, 0.0), MaxCameraZ, CameraZRange, Positions[1], PlaneAlpha[1]);\n"
"    ComputePlaneIntersectionAttribs(Camera, RayWS, float3(0.0, 0.0, 1.0), MaxCameraZ, CameraZRange, Positions[2], PlaneAlpha[2]);\n"
"\n"
"    float4 GridResult = float4(0.0, 0.0, 0.0, 0.0);\n"
"    float4 AxisResult = float4(0.0, 0.0, 0.0, 0.0);\n"
"\n"
"#if COORDINATE_GRID_AXIS_X\n"
"    {\n"
"        AxisResult += float4(GridAttribs.XAxisColor.xyz, 1.0) *\n"
"                      ComputeAxisAlpha(float3(1.0, 0.0, 0.0), RayWS, Camera.fFarPlaneZ, PixelSize * GridAttribs.XAxisWidth, MaxCameraZ, CameraZRange, Camera.mView);\n"
"    }\n"
"#endif\n"
"\n"
"#if COORDINATE_GRID_AXIS_Y\n"
"    {\n"
"        AxisResult += float4(GridAttribs.YAxisColor.xyz, 1.0) *\n"
"                      ComputeAxisAlpha(float3(0.0, 1.0, 0.0), RayWS, Camera.fFarPlaneZ, PixelSize * GridAttribs.YAxisWidth, MaxCameraZ, CameraZRange, Camera.mView);\n"
"    }\n"
"#endif\n"
"\n"
"#if COORDINATE_GRID_AXIS_Z\n"
"    {\n"
"        AxisResult += float4(GridAttribs.ZAxisColor.xyz, 1.0) *\n"
"                      ComputeAxisAlpha(float3(0.0, 0.0, 1.0), RayWS, Camera.fFarPlaneZ, PixelSize * GridAttribs.ZAxisWidth, MaxCameraZ, CameraZRange, Camera.mView);\n"
"    }\n"
"#endif\n"
"\n"
"#if COORDINATE_GRID_PLANE_YZ\n"
"    {\n"
"        GridResult += ComputeGrid(Positions[0].yz, GridAttribs.GridScale.x, GridAttribs.GridSubdivision.x, GridAttribs) * PlaneAlpha[0];\n"
"    }\n"
"#endif\n"
"\n"
"#if COORDINATE_GRID_PLANE_XZ\n"
"    {\n"
"        GridResult += ComputeGrid(Positions[1].xz, GridAttribs.GridScale.y, GridAttribs.GridSubdivision.y, GridAttribs) * PlaneAlpha[1];\n"
"    }\n"
"#endif\n"
"\n"
"#if COORDINATE_GRID_PLANE_XY\n"
"    {\n"
"        GridResult += ComputeGrid(Positions[2].xy, GridAttribs.GridScale.z, GridAttribs.GridSubdivision.z, GridAttribs) * PlaneAlpha[2];\n"
"    }\n"
"#endif\n"
"\n"
"    float4 Result;\n"
"    Result.rgb = GridResult.rgb * exp(-10.0 * AxisResult.a * AxisResult.a) + AxisResult.rgb;\n"
"    Result.a   = GridResult.a * (1.0 - AxisResult.a) + AxisResult.a;\n"
"\n"
"    return Result;\n"
"}\n"
"\n"
"#endif //_COORDINATE_GRID_FXH_\n"
